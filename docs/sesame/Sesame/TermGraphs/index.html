<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>TermGraphs (sesame.Sesame.TermGraphs)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../index.html">sesame</a> &#x00BB; <a href="../index.html">Sesame</a> &#x00BB; TermGraphs</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Sesame.TermGraphs</span></code></h1><p>Data types used to represent terms and states of the SESAME machine.</p><p>A term graph is essentially a DAG that captures the syntactic structure of a term, augmented with a few backpointers from cut variables to the terms that surround the cuts. These backpointers are used to consume the cut during multiplicative steps.</p><p>In a term graph all occurrences of a variable are shared, i.e. they are all pointers to the same node in memory. If the variable is bound by a cut or a subtraction or a dereliction, then its node points to the cut value or to the arguments of the subtraction/dereliction. For example, if <code>x</code> is bound by the cut <code>[v-x]</code>, then the node for <code>x</code> points to <code>v</code> and it remembers that it is a cut. A term which is not a value (e.g. <code>[v-x]t</code>) is represented by a node that points both to the subterm <code>t</code> and to the bound variable <code>x</code> which, in turn, will point to the subterms of the binder (<code>v</code> in this case).</p><p>The pool of the machine is a list of jobs where each job is implemented simply as a pointer inside the term graph that points to the term that needs to be reduced. For example, a machine state <code>!Œªm&lt;&gt;‚Çê, &lt;t&gt;‚Çê::œµ</code> of the paper is implemented as the pair made by the term graph for <code>!Œªmt</code> and a singleton list made of a pointer to the root of the subgraph that encodes <code>t</code>.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-me"><a href="#type-me" class="anchor"></a><code><span><span class="keyword">type</span> me</span><span> = </span></code><ol><li id="type-me.Mul" class="def variant constructor anchored"><a href="#type-me.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span></span></code></li><li id="type-me.Exp" class="def variant constructor anchored"><a href="#type-me.Exp" class="anchor"></a><code><span>| </span><span><span class="constructor">Exp</span></span></code></li></ol></div><div class="spec-doc"><p>Used to differentiate between multiplicative and exponential variables</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-value"><a href="#type-value" class="anchor"></a><code><span><span class="keyword">type</span> value</span><span> = </span></code><ol><li id="type-value.Var" class="def variant constructor anchored"><a href="#type-value.Var" class="anchor"></a><code><span>| </span><span><span class="constructor">Var</span> <span class="keyword">of</span> <a href="#type-var">var</a></span></code></li><li id="type-value.Abs" class="def variant constructor anchored"><a href="#type-value.Abs" class="anchor"></a><code><span>| </span><span><span class="constructor">Abs</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-value.var" class="def record field anchored"><a href="#type-value.var" class="anchor"></a><code><span>var : <a href="#type-var">var</a>;</span></code></li><li id="type-value.bo" class="def record field anchored"><a href="#type-value.bo" class="anchor"></a><code><span><span class="keyword">mutable</span> bo : <a href="#type-term">term</a>;</span></code></li></ol><code><span>}</span></code></li><li id="type-value.Bang" class="def variant constructor anchored"><a href="#type-value.Bang" class="anchor"></a><code><span>| </span><span><span class="constructor">Bang</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-value.bo" class="def record field anchored"><a href="#type-value.bo" class="anchor"></a><code><span><span class="keyword">mutable</span> bo : <a href="#type-term">term</a>;</span></code></li></ol><code><span>}</span></code></li></ol></div><div class="spec-doc"><p>A value is either a variable occurrence, an abstraction or an exponential box</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-var"><a href="#type-var" class="anchor"></a><code><span><span class="keyword">and</span> var</span><span> = </span><span>{</span></code><ol><li id="type-var.is" class="def record field anchored"><a href="#type-var.is" class="anchor"></a><code><span><span class="keyword">mutable</span> is : <span><a href="#type-bvar">bvar</a> option</span>;</span></code></li><li id="type-var.kind" class="def record field anchored"><a href="#type-var.kind" class="anchor"></a><code><span>kind : <a href="#type-me">me</a>;</span></code></li><li id="type-var.name" class="def record field anchored"><a href="#type-var.name" class="anchor"></a><code><span>name : int;</span></code></li><li id="type-var.copy" class="def record field anchored"><a href="#type-var.copy" class="anchor"></a><code><span><span class="keyword">mutable</span> copy : <a href="#type-var">var</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A <code>var</code> is the unique node in memory associated to a variable. Variable occurrences and binders point to this node.</p><p>The is field is <code>None</code> for free variable and variables bound by abstractions. Otherwise it points the node holding the information about the binder.</p><p>The kind field distinguish multiplicative from exponential variables.</p><p>The name field is the positive integer used to differentiate variables. A variable is identified both by its kind and name so that <code>m‚ÇÅ</code> (a variable of kind <code>Mult</code> and name <code>1</code>) is different from <code>e‚ÇÅ</code> (a variable of kind <code>Exp</code> and name <code>1</code>).</p><p>The copy field is used during alpha-renaming (i.e. subgraph copying) to preserve sharing. When a variable is copied to a new one, it points to the new one. Variables that have never been copied point to themselves.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-bvar"><a href="#type-bvar" class="anchor"></a><code><span><span class="keyword">and</span> bvar</span><span> = </span></code><ol><li id="type-bvar.Cut" class="def variant constructor anchored"><a href="#type-bvar.Cut" class="anchor"></a><code><span>| </span><span><span class="constructor">Cut</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-bvar.v" class="def record field anchored"><a href="#type-bvar.v" class="anchor"></a><code><span>v : <a href="#type-value">value</a>;</span></code></li><li id="type-bvar.ptr" class="def record field anchored"><a href="#type-bvar.ptr" class="anchor"></a><code><span><span class="keyword">mutable</span> ptr : <span><a href="#type-ptr">ptr</a> option</span>;</span></code></li></ol><code><span>}</span></code></li><li id="type-bvar.MElim" class="def variant constructor anchored"><a href="#type-bvar.MElim" class="anchor"></a><code><span>| </span><span><span class="constructor">MElim</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-bvar.var" class="def record field anchored"><a href="#type-bvar.var" class="anchor"></a><code><span><span class="keyword">mutable</span> var : <a href="#type-var">var</a>;</span></code></li><li id="type-bvar.v" class="def record field anchored"><a href="#type-bvar.v" class="anchor"></a><code><span><span class="keyword">mutable</span> v : <a href="#type-value">value</a>;</span></code></li></ol><code><span>}</span></code></li><li id="type-bvar.EElim" class="def variant constructor anchored"><a href="#type-bvar.EElim" class="anchor"></a><code><span>| </span><span><span class="constructor">EElim</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-bvar.var" class="def record field anchored"><a href="#type-bvar.var" class="anchor"></a><code><span><span class="keyword">mutable</span> var : <a href="#type-var">var</a>;</span></code></li></ol><code><span>}</span></code></li></ol></div><div class="spec-doc"><p>A <code>bvar</code> represents a cut or a subtraction or a dereliction, that are all binders. The node points to the variables or values used in the binder.</p><p>Cuts also hold an optional pointer to the <code>Bind</code> term that binds the variable. The pointer is used during reduction to consume multiplicative cuts. To simplify the parser, it can be <code>None</code> in initial terms, but it must be set in approximants.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-term"><a href="#type-term" class="anchor"></a><code><span><span class="keyword">and</span> term</span><span> = </span></code><ol><li id="type-term.Val" class="def variant constructor anchored"><a href="#type-term.Val" class="anchor"></a><code><span>| </span><span><span class="constructor">Val</span> <span class="keyword">of</span> <a href="#type-value">value</a></span></code></li><li id="type-term.Bind" class="def variant constructor anchored"><a href="#type-term.Bind" class="anchor"></a><code><span>| </span><span><span class="constructor">Bind</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-term.var" class="def record field anchored"><a href="#type-term.var" class="anchor"></a><code><span>var : <a href="#type-var">var</a>;</span></code></li><li id="type-term.t" class="def record field anchored"><a href="#type-term.t" class="anchor"></a><code><span><span class="keyword">mutable</span> t : <a href="#type-term">term</a>;</span></code></li></ol><code><span>}</span></code></li></ol></div><div class="spec-doc"><p>A <code>term</code> is either a (node pointing to a) value or a binder pointing to the bound variable and the remaining term.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-topterm"><a href="#type-topterm" class="anchor"></a><code><span><span class="keyword">and</span> topterm</span><span> = <span><a href="#type-term">term</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p><code>topterm</code> is the root of the term graph. Initially it represents the term to be reduced. When the machine stops, it contains the normal form.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-ptr"><a href="#type-ptr" class="anchor"></a><code><span><span class="keyword">and</span> ptr</span><span> = </span></code><ol><li id="type-ptr.Initial" class="def variant constructor anchored"><a href="#type-ptr.Initial" class="anchor"></a><code><span>| </span><span><span class="constructor">Initial</span> <span class="keyword">of</span> <a href="#type-topterm">topterm</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>points to the <code>topterm</code></p><span class="comment-delim">*)</span></div></li><li id="type-ptr.InsideBang" class="def variant constructor anchored"><a href="#type-ptr.InsideBang" class="anchor"></a><code><span>| </span><span><span class="constructor">InsideBang</span> <span class="keyword">of</span> <a href="#type-value">value</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>value</code> must be a <code>Bang</code></p><span class="comment-delim">*)</span></div></li><li id="type-ptr.InsideAbs" class="def variant constructor anchored"><a href="#type-ptr.InsideAbs" class="anchor"></a><code><span>| </span><span><span class="constructor">InsideAbs</span> <span class="keyword">of</span> <a href="#type-value">value</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>value</code> must be an <code>Abs</code></p><span class="comment-delim">*)</span></div></li><li id="type-ptr.InsideBind" class="def variant constructor anchored"><a href="#type-ptr.InsideBind" class="anchor"></a><code><span>| </span><span><span class="constructor">InsideBind</span> <span class="keyword">of</span> <a href="#type-term">term</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>value</code> must be a <code>Bind</code></p><span class="comment-delim">*)</span></div></li><li id="type-ptr.InsideMElim" class="def variant constructor anchored"><a href="#type-ptr.InsideMElim" class="anchor"></a><code><span>| </span><span><span class="constructor">InsideMElim</span> <span class="keyword">of</span> <a href="#type-bvar">bvar</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>bvar</code> must be an <code>MElim</code></p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>In OCaml it is not possible to take the address of a record field to mutate it. One needs to have a reference to the whole record instead. The <code>ptr</code> datatype represents a pointer inside the term graph by listing all the constructors (i.e. labelled records) that have fields that are subterms different from variables (i.e. all the positions where an hole can occur in an approximant).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pool"><a href="#type-pool" class="anchor"></a><code><span><span class="keyword">type</span> pool</span><span> = <span><a href="#type-ptr">ptr</a> list</span></span></code></div><div class="spec-doc"><p>A pool is a list of pointers <code>ptr</code> to the maximal subterms that are still to be evaluated. Equivalently, it is a list of pointers to the subterms that have been replaced by holes in an approximant.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-deref"><a href="#val-deref" class="anchor"></a><code><span><span class="keyword">val</span> deref : <span><a href="#type-ptr">ptr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-term">term</a></span></code></div><div class="spec-doc"><p><code>deref ptr</code> returns the subterm pointed by <code>ptr</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assign"><a href="#val-assign" class="anchor"></a><code><span><span class="keyword">val</span> assign : <span><a href="#type-ptr">ptr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>assign ptr t</code> mutates the term graph in place by assigning <code>t</code> to the pointer <code>ptr</code></p></div></div></div></body></html>
